# c.康托展开

## 题目

利用康托展开求某组合数在全排列（从小到大）中的位置。

康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数（1，2，3，4,…,n），可以有组成不同(n!种)的排列组合，康托展开表示的就是是当前排列组合在n个不同元素的全排列中的名次。 

康托展开：X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0! 

其中，a[i]为整数，a[n]代表的是元素所在的排序（从0 开始）

## 思路

例如有3个数（1，2，3），则其排列组合及其相应的康托展开值如下：

| 排列组合 | 名次 | 康托展开                 |
| -------- | ---- | ------------------------ |
| 123      | 1    | 0 * 2! + 0 * 1! + 0 * 0! |
| 132      | 2    | 0 * 2! + 1 * 1! + 0 * 0! |
| 213      | 3    | 1 * 2! + 0 * 1! + 0 * 0! |
| 231      | 4    | 1 * 2! + 1 * 1! + 0 * 0! |
| 312      | 5    | 2 * 2! + 0 * 1! + 0 * 0! |
| 321      | 6    | 2 * 2! + 1 * 1! + 0 * 0! |

比如其中的 231：

- 想要计算排在它前面的排列组合数目（123，132，213），则可以转化为计算比首位小即小于2的所有排列「1 * 2！」，首位相等为2并且第二位小于3的所有排列「1 * 1！」，前两位相等为23并且第三位小于1的所有排列（0 * 0！）的和即可，康托展开为：1 * 2！+1 * 1+0 * 0=3。
- 所以小于231的组合有3个，所以231的名次是4。

再举个例子说明。
在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。

- 首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为 a[5]*(5-1)!
- 第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2
- 第三位是1，则在其之后小于1的数有0个，所以a[3]=0
- 第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1
- 最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0
- 根据公式：
  `X = 2 * 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0! = 2 * 24 + 2 * 6 + 1 = 61`
  所以比 34152 小的组合有61个，即34152是排第62。

## 代码

```C
#include<stdio.h>
#define Max 100
 
int factorial_function(int num)		//求阶乘
{
	if(num <= 1)
		return 1;
	else
		return (factorial_function(num-1)*num);
}
 
int main()
{
	int num[Max];
	char s[Max];
	int i=0,j=0,k=0,count=0;
	char val;
	int sum = 0;
 
	while(scanf("%c",&val))	//获取元素，如 A C B D 或 1324 
	{
		if(val == '\n')
			break;
		else
		{
			s[count] = val;
			count ++;
		}
	}
 
	//printf("count = %d\n",count);
 
	
	for(i=0;i<count;i++)	// 分别求得元素的排序，如第一个元素需要和剩下的n-1个比较，
	{						//第二个元素需要和剩下的n-2个比较，第三个元素需要和剩下的n-3个元素进行比较等等
		//printf("*************************%c************************\n",s[i]);
		for(j=i+1;j<count;j++)
		{
			if(s[i]>s[j])
			{
				//printf("位置%d: %c > %c\n",j,s[i],s[j]);
				k ++;	 
			}
			
		}
		//printf("%d\n",k);
		num[i] = k;		//有几个数比当前元素小
		k = 0;
	}
	
	for(j=count-1;j>=0;j--)		//输出结果 
	{
		sum += factorial_function(j) * num[k];
		//printf("%d:%d = %d*%d\n",k,sum,factorial_function(j),num[k]);
		k++;
		//printf("%c",s[k++]);
	}
	printf("是第%d大数\n",sum+1);
 
	return 0;
}
```



