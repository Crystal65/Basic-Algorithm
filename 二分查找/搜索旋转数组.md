# [搜索旋转数组](https://leetcode-cn.com/problems/search-rotate-array-lcci/)

## 题目

搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

- 示例1:

   输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
   输出: 8（元素5在该数组中的索引）

- 示例2:

   输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11
   输出：-1 （没有找到）

## 思路

本题最大的问题就是出现重复元素之后，划分左右两端时候，查找的元素可能同时存在于左右两边，因此仅需要保证划分后两侧元素各不相同即可
两侧出现重复元素的情况分为两种:
第一种，类似于[5,6,7,1,2,4,5,5]这样的，最左端和最右端重复。
这种情况比较容易处理，直接r--调整最右端，去除最右端的元素直到nums[l]!=nums[r]即可，处理完之后就变成了[5,6,7,1,2,4],在此之后，再算mid的位置。

第二种，类似于[15,16,19,20,25,1,1,3,4,5,7,10,14],划分后，左边[15,16,19,20,25,1],右边[1,3,4,5,7,10,14],即中间重复了。
对于这种情况，我们想办法把划分变成[15,16,19,20,25,1,1]和[3,4,5,7,10,14] (或者[15,16,19,20,25],右边[1,1,3,4,5,7,10,14]), 即,把通过调整mid的位置，将中间重复的元素统一划给一侧，使得两侧元素互不相同。

接下来的情况就和普通的查找相同了

## 代码

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size()==0) return -1;
        int l = 0, r = nums.size()-1, mid, mid2;
        while(l<r){
            while(nums[l]==nums[r] && r>l) r--;//首先去除最右边的重复元素
            mid = (l+r)/2;
            if(mid+1<=r){                      //将划分边界上重复的数字全部滑向右边     
               int temp = nums[mid+1];
               for(int i=mid;i>=l;i--){
                   if (nums[i]!=temp){
                       mid = i;
                       break;
                   }
               }
            }
            if(nums[l]<=nums[mid]){ //左边有序，先看左边
                if(target>=nums[l] && target<=nums[mid]) r = mid;
                else l = mid+1;
            }
            else{                   //右边有序，先看右边
                if(target>=nums[mid+1] && target<=nums[r]) l = mid+1;
                else r = mid;
            }
        }
        if(nums[l] == target) return l;
        else return -1;
    }
};
```

